
R version 2.8.1 (2008-12-22)
Copyright (C) 2008 The R Foundation for Statistical Computing
ISBN 3-900051-07-0

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> ### * <HEADER>
> ###
> attach(NULL, name = "CheckExEnv")
> assign("nameEx", 
+        local({
+ 	   s <- "__{must remake R-ex/*.R}__"
+            function(new) {
+                if(!missing(new)) s <<- new else s
+            }
+        }),
+        pos = "CheckExEnv")
> ## Add some hooks to label plot pages for base and grid graphics
> assign("base_plot_hook",
+        function() {
+            pp <- par(c("mfg","mfcol","oma","mar"))
+            if(all(pp$mfg[1:2] == c(1, pp$mfcol[2]))) {
+                outer <- (oma4 <- pp$oma[4]) > 0; mar4 <- pp$mar[4]
+                mtext(sprintf("help(\"%s\")", nameEx()), side = 4,
+                      line = if(outer)max(1, oma4 - 1) else min(1, mar4 - 1),
+                outer = outer, adj = 1, cex = .8, col = "orchid", las=3)
+            }
+        },
+        pos = "CheckExEnv")
> assign("grid_plot_hook",
+        function() {
+            grid::pushViewport(grid::viewport(width=grid::unit(1, "npc") - 
+                               grid::unit(1, "lines"), x=0, just="left"))
+            grid::grid.text(sprintf("help(\"%s\")", nameEx()),
+                            x=grid::unit(1, "npc") + grid::unit(0.5, "lines"),
+                            y=grid::unit(0.8, "npc"), rot=90,
+                            gp=grid::gpar(col="orchid"))
+        },
+        pos = "CheckExEnv")
> setHook("plot.new",     get("base_plot_hook", pos = "CheckExEnv"))
> setHook("persp",        get("base_plot_hook", pos = "CheckExEnv"))
> setHook("grid.newpage", get("grid_plot_hook", pos = "CheckExEnv"))
> assign("cleanEx",
+        function(env = .GlobalEnv) {
+ 	   rm(list = ls(envir = env, all.names = TRUE), envir = env)
+            RNGkind("default", "default")
+ 	   set.seed(1)
+    	   options(warn = 1)
+ 	   .CheckExEnv <- as.environment("CheckExEnv")
+ 	   delayedAssign("T", stop("T used instead of TRUE"),
+ 		  assign.env = .CheckExEnv)
+ 	   delayedAssign("F", stop("F used instead of FALSE"),
+ 		  assign.env = .CheckExEnv)
+ 	   sch <- search()
+ 	   newitems <- sch[! sch %in% .oldSearch]
+ 	   for(item in rev(newitems))
+                eval(substitute(detach(item), list(item=item)))
+ 	   missitems <- .oldSearch[! .oldSearch %in% sch]
+ 	   if(length(missitems))
+ 	       warning("items ", paste(missitems, collapse=", "),
+ 		       " have been removed from the search path")
+        },
+        pos = "CheckExEnv")
> assign("ptime", proc.time(), pos = "CheckExEnv")
> ## at least one package changes these via ps.options(), so do this
> ## before loading the package.
> ## Use postscript as incomplete files may be viewable, unlike PDF.
> ## Choose a size that is close to on-screen devices, fix paper
> ps.options(width = 7, height = 7, paper = "a4", reset = TRUE)
> grDevices::postscript("dcemri-Ex.ps")
> 		      
> assign("par.postscript", graphics::par(no.readonly = TRUE), pos = "CheckExEnv")
> options(contrasts = c(unordered = "contr.treatment", ordered = "contr.poly"))
> options(warn = 1)    
> library('dcemri')
Loading required package: splines
> 
> assign(".oldSearch", search(), pos = 'CheckExEnv')
> assign(".oldNS", loadedNamespaces(), pos = 'CheckExEnv')
> cleanEx(); nameEx("dce.bayes")
> ### * dce.bayes
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dcemri.bayes
> ### Title: Bayesian Methods for Pharmacokinetic Modeling of Dynamic
> ###   Contrast-Enhanced MRI Data
> ### Aliases: dcemri.bayes
> ### Keywords: models
> 
> ### ** Examples
> 
> data("buckley")
> img <- array(t(breast$data)[, (1:60)*5], c(13, 1, 1, 60))
> time <- seq(5, 300, by=5) / 60
> mask <- array(rep(TRUE, 13), c(13,1,1))
> #Generate AIF params using the orton.exp function from Buckley's AIF
> aifparams <- with(buckley, orton.exp.lm(time.min,input))
Loading required package: minpack.lm

This product includes software developed by the University of Chicago, as
Operator of Argonne National Laboratory.

See the LICENSE file distributed with the minpack.lm source code or
http://www.netlib.org/minpack/disclaimer for the full license.

> aifparams$D<-1
> 
> system.time(fit.bayes <- dcemri.bayes(img, time, mask, aif="fritz.hansen"))
  Deconstructing data...
  Estimating the kinetic parameters...
  Reconstructing results...
   user  system elapsed 
 42.070   0.132  48.982 
> system.time(fit.bayes.aif <- dcemri.bayes(img, time, mask, model="orton.exp", aif="user", user=aifparams))
  Deconstructing data...
  User-specified AIF parameters...
  Estimating the kinetic parameters...
  Reconstructing results...
   user  system elapsed 
 64.912   0.220  73.767 
> plot(breast$ktrans, fit.bayes$ktrans, xlim=c(0,0.75), ylim=c(0,0.75),
+      xlab="True Ktrans", ylab="Estimated Ktrans (Bayes)")
> points(breast$ktrans, fit.bayes.aif$ktrans, pch=2)
> legend(0.4, 0.2, pch=c(2,1), legend=c("Orton Exp (modelled)","Fritz Hansen"))
> lines(c(-0.1,0.8), c(-0.1,0.8), lty=3, col="grey")
> 
> system.time(fit.lm <- dcemri.lm(img, time, mask, aif="fritz.hansen"))
  Deconstructing data...
  Estimating the kinetic parameters...
  Reconstructing results...
   user  system elapsed 
  0.124   0.000   0.123 
> system.time(fit.lm.aif <- dcemri.lm(img, time, mask, model="orton.exp", aif="user", user=aifparams))
  Deconstructing data...
  User-specified AIF parameters...
  Estimating the kinetic parameters...
  Reconstructing results...
   user  system elapsed 
  0.164   0.000   0.169 
> plot(breast$ktrans, fit.bayes$ktrans, xlim=c(0,0.75), ylim=c(0,0.75),
+      xlab="True Ktrans", ylab="Estimated Ktrans")
> points(breast$ktrans, fit.bayes.aif$ktrans, pch=3)
> points(breast$ktrans, fit.lm$ktrans, pch=2)
> points(breast$ktrans, fit.lm.aif$ktrans, pch=4)
> 
> legend(0.6, 0.2, pch=c(4,3,2,1), legend=c("LM OE","Bayes OE","LM FH","Bayes FH"))
> lines(c(-0.1,0.8), c(-0.1,0.8), lty=3, col="grey")
> 
> # not for windows, yet
> ## Not run: 
> ##D system.time(fit.bayes <- dcemri.bayes(img, time, mask, aif="fritz.hansen", samples=TRUE, multicore=TRUE))
> ## End(Not run)
> 
> 
> 
> cleanEx(); nameEx("dce.spline")
> ### * dce.spline
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dcemri.spline
> ### Title: Bayesian P-Splines for Dynamic Contrasat-Enhanced MRI Data
> ### Aliases: dcemri.spline
> ### Keywords: models
> 
> ### ** Examples
> 
> data("buckley")
> img <- array(t(breast$data)[,(1:60)*5], c(13,1,1,60))
> time <- seq(5,300,5) / 60
> mask <- array(rep(TRUE, 13), c(13,1,1))
> #Generate AIF params using the orton.exp function from Buckley's AIF
> aifparams <- with(buckley, orton.exp.lm(time.min,input))
Loading required package: minpack.lm

This product includes software developed by the University of Chicago, as
Operator of Argonne National Laboratory.

See the LICENSE file distributed with the minpack.lm source code or
http://www.netlib.org/minpack/disclaimer for the full license.

> aifparams$D<-1 
> pseudoobservedaif=aif.orton.exp(tt=time,AB=aifparams$AB,AG=aifparams$AG,muB=aifparams$muB,muG=aifparams$muG)
> 
> fit.spline <- dcemri.spline(img, time, mask, aif="fritz.hansen", nlr=TRUE)
  Deconstructing data...
  Estimating the parameters...
  Reconstructing results...
> fit.spline.aif <- dcemri.spline(img, time, mask, aif="observed", aif.observed=pseudoobservedaif, nlr=TRUE)
  Deconstructing data...
  Estimating the parameters...
Warning in nls.lm(par = par, fn = fn, fcall = fcall2, time = time, x = fitted,  :
  lmdif: info = -1. Number of iterations has reached `maxiter' == 50.

  Reconstructing results...
> 
> plot(breast$ktrans, fit.spline$ktrans, xlim=c(0,0.75), ylim=c(0,0.75),
+      xlab="True Ktrans", ylab="Estimated Ktrans (Spline)")
> points(breast$ktrans, fit.spline.aif$ktrans, pch=2)
> legend(0.4, 0.2, pch=c(2,1), legend=c("Modelled AIF","Fritz Hansen"))
> lines(c(-0.1,0.8), c(-0.1,0.8), lty=3, col="grey")
> 
> # Multicore options, not working for windows yet
> ## Not run: 
> ##D system.time(fit <- dcemri.spline(img, time, mask, aif="fritz.hansen",nlr=TRUE,multicore=TRUE))
> ## End(Not run)
> 
> 
> 
> cleanEx(); nameEx("dcemri")
> ### * dcemri
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dcemri
> ### Title: Pharmacokinetic Models for Dynamic Contrast-Enhanced MRI Data
> ### Aliases: dcemri.lm
> ### Keywords: models
> 
> ### ** Examples
> 
> data("buckley")
> #Set up breast data for dcemri
> img <- array(t(breast$data)[,(1:60)*5], c(13,1,1,60))
> time <- seq(5, 300, by=5) / 60
> mask <- array(rep(TRUE, 13), c(13,1,1))
> #Generate AIF params using the orton.exp function from Buckley's AIF
> aifparams <- with(buckley, orton.exp.lm(time.min,input))
Loading required package: minpack.lm

This product includes software developed by the University of Chicago, as
Operator of Argonne National Laboratory.

See the LICENSE file distributed with the minpack.lm source code or
http://www.netlib.org/minpack/disclaimer for the full license.

> aifparams$D<-1
> fit <- dcemri.lm(img, time, mask, model="orton.exp", aif="user", user=aifparams)
  Deconstructing data...
  User-specified AIF parameters...
  Estimating the kinetic parameters...
  Reconstructing results...
> 
> plot(breast$ktrans, fit$ktrans, xlim=c(0,0.75), ylim=c(0,0.75), xlab="True Ktrans", ylab="Estimated Ktrans")
> lines(c(-0.1,0.8), c(-0.1,0.8), lty=3, col="grey")
> 
> 
> 
> 
> cleanEx(); nameEx("find.center")
> ### * find.center
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: find.center
> ### Title: Find the Center of a Binary Mask
> ### Aliases: find.center
> ### Keywords: misc
> 
> ### ** Examples
> 
> M <- array(FALSE, rep(10,3))
> M[6:10,6:10,6:10] <- TRUE
> Mc <- find.center(M)
> 
> 
> 
> cleanEx(); nameEx("hotmetal")
> ### * hotmetal
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: hotmetal
> ### Title: Hot Metal Color Table
> ### Aliases: hotmetal
> ### Keywords: aplot
> 
> ### ** Examples
> 
> hotmetal(10) 
 [1] "#010000" "#4C0000" "#960000" "#E00000" "#FF2C00" "#FF7600" "#FFC100"
 [8] "#FFFF12" "#FFFF81" "#FFFFF1"
> image(outer(1:20,1:20,"+"), col=hotmetal(75), main="hotmetal")
> 
> 
> 
> cleanEx(); nameEx("kineticmodel")
> ### * kineticmodel
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: kineticmodel
> ### Title: Pharmacokinetic Models
> ### Aliases: kineticmodel
> ### Keywords: models
> 
> ### ** Examples
> 
> data("buckley")
> img <- array(t(breast$data)[,(1:60)*5], c(13,1,1,60))
> time <- seq(5, 300, by=5) / 60
> mask <- array(rep(TRUE, 13), c(13,1,1))
> fit <- dcemri.lm(img, time, mask, aif="fritz.hansen")
Loading required package: minpack.lm

This product includes software developed by the University of Chicago, as
Operator of Argonne National Laboratory.

See the LICENSE file distributed with the minpack.lm source code or
http://www.netlib.org/minpack/disclaimer for the full license.

  Deconstructing data...
  Estimating the kinetic parameters...
  Reconstructing results...
> curve <- kineticmodel(time,list("ktrans"=fit$ktrans[3],"kep"=fit$kep[3],"vp"=fit$vp[3]))
> ## Not run: curve
> 
> plot(time,img[3,1,1,],xlab="time",ylab="conc")
> lines(time,curve)
> 
> fit <- dcemri.bayes(img, time, mask, aif="fritz.hansen",multicore=TRUE)
  Deconstructing data...
  Estimating the kinetic parameters...
Loading required package: multicore
  Reconstructing results...
> curve <- kineticmodel(time,list("ktrans"=fit$ktrans[3],"kep"=fit$kep[3],"vp"=fit$vp[3]))
> lines(time,curve,col="blue")
> 
> 
> 
> cleanEx(); nameEx("tim.colors")
> ### * tim.colors
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tim.colors
> ### Title: Tim's Useful Color Table
> ### Aliases: tim.colors
> ### Keywords: aplot
> 
> ### ** Examples
> 
> tim.colors(10) 
 [1] "#00008F" "#0000FF" "#0070FF" "#00DFFF" "#50FFAF" "#BFFF40" "#FFCF00"
 [8] "#FF6000" "#EF0000" "#800000"
> image(outer(1:20, 1:20, "+"), col=tim.colors(75), main="tim.colors")
> 
> 
> 
> cleanEx(); nameEx("write")
> ### * write
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Write Output as Analyze/NIfTI
> ### Title: Write Analyze/NIfTI Format Binary Image Files
> ### Aliases: write.analyze.img write.nifti.img
> ### Keywords: file
> 
> ### ** Examples
> 
> X <- Y <- Z <- 64
> img <- array(sample(c(0,1), X*Y*Z, replace=TRUE), c(X,Y,Z))
> ## Analyze
> hdr <- make.hdr(X, Y, Z, 1, "int16")
> write.analyze.img("xyz64", hdr, img, "int16")
> ## NIfTI
> nhdr <- make.hdr(X, Y, Z, 1, "INT", "nifti")
> write.nifti.img("XYZ64", nhdr, img, "int16")
> ## These files should be viewable in, for example, FSLview.
> ## Make sure you adjust the min/max values for proper visualization.
> data <- read.img("XYZ64.nii.gz")
Loading required package: bitops
> 
> 
> 
> ### * <FOOTER>
> ###
> cat("Time elapsed: ", proc.time() - get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  224.246 1.36 304.286 19.101 19.101 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
